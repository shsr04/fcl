;;; fcl parser

(define Node.print (lambda () ()))
(define-structure 
	(Node
		(constructor node.new (name op))
	)
	name	; symbol
	op		; symbol|number
)
(define (Node.unpack p)
	(list (node-name p) (node-op p))
)

; parse : [Token],number -> [Node]
(define (parse tokens)
	; eq : number,symbol -> boolean
	(define (eq i t)
		(eq? (token-name (list-ref tokens i)) t)
	)
	; getp : number -> symbol
	(define (getp i)
		(let ((t (token-payl (list-ref tokens i))))
			(if (null? t)
				(token-name (list-ref tokens i))
				(if (number? t)
					t
					(string->symbol t)
				)
			)
		)
	)
	; descend-into : (number,[Node]->{number,[Node]}),number,[Node] -> {number,[Node]} 
	(define (descend-into target i s onSuccess . onError)
		(let* (($result (target i s)) (ri (car $result)) (rs (cdr $result)))
			(if (> ri 0)
				(onSuccess ri rs) ; do something with rs
				(if (null? onError)
					$result
					((car onError) ri rs)
				)
			)
		)
	)

	; Program ::= Definitions;
	; Definitions ::= Definition Definitions | Definition eof;
	; Definition ::= Identifier ParameterTuple Guard equal Expression semicolon;
	; Identifier ::= word;
	; Identifiers ::= Identifier comma Identifiers | Identifier ;
	; ParameterTuple ::= left-par Identifiers right-par | ;
	; Guard ::= bar LogicalExpression GuardElse;
	; GuardElse ::= colon Expression | ; 
	; LogicalExpression ::= Expression tilde Expression | Expression bang Expression
	;		| Expression greater Expression | Expression less Expression;
	; Expressions ::= Expression comma Expressions | Expressions;
	; Expression ::= Term Expression2
	; Expression2 ::= plus Term Expression2 | minus Term Expression2 | ;
	; Term ::= Factor Term2
	; Term2 ::= star Factor Term2 | slash Factor Term2 | ;
	; Factor ::= number | FunctionValue | left-par Term right-par;
	; FunctionValue ::= Identifier ArgumentTuple;
	; ArgumentTuple ::= left-par Expressions right-par | left-par right-par | ;
	(define (Program i)
		(descend-into Definitions i '()
			(lambda (a l)
				(fmt "successfully parsed" a "tokens")
				(reverse l)
			)
			(lambda (a l)
				(fmt "syntax error on" (if (< (abs a) (length tokens)) (list-ref tokens (abs a)) -1) (getp (abs a)))
				'!syntax-error
			)
		)
	)
	(define (Definitions i s)
		(descend-into Definition i s
			(lambda (a l)
				(if (eq a 'eof)		;	EOF reached
					(cons (+ a 1) l)
					(Definitions a l)
				)
			)
		)
	)
	(define (Definition i s)
		(if debug.parse (fmt "Def" i))
		;(if (eq i 'word)
		(descend-into Identifier i s
			(lambda (a l)
				(descend-into ParameterTuple a (cons (node.new 'begin-def (getp i)) l)
					(lambda (a l)
						(descend-into Guard a l
							(lambda (b l)
								(if (eq b 'equal)
									(descend-into Expression (+ b 1) (cons (node.new 'begin-term '()) l)
										(lambda (c l)
											(if (eq c 'semicolon)
												(cons (+ c 1) (cons (node.new 'end-def '()) (cons (node.new 'end-term '()) l)))
												(cons (- c) '())
											)
										)
									)
									(cons (- b) '())
								)
							)
						)
					)
				)
			)
		)
	)
	(define (Expression i s)
		(if debug.parse (fmt "Expr" i))
		(descend-into Term i s
			(lambda (a l)
				(Expression2 a l)
			)
		)
	)
	(define (Expression2 i s)
		(if debug.parse (fmt "Expr2" i))
		(if (or (eq i 'plus) (eq i 'minus))
			(descend-into Term (+ i 1) s
				(lambda (a l)
					(Expression2 a (cons (node.new (cond ((eq i 'plus) 'add) ((eq i 'minus) 'sub)) '()) l))
				)
			)
			(cons i s)
		)
	)
	(define (Term i s)
		(if debug.parse (fmt "Term" i))
		(descend-into Factor i s
			(lambda (a l)
				(Term2 a l)
			)
		)
	)
	(define (Term2 i s)
		(if debug.parse (fmt "Term2" i ))
		(if (or (eq i 'star) (eq i 'slash))
			(descend-into Factor (+ i 1) s
				(lambda (a l)
					(Term2 a (cons (node.new (cond ((eq i 'star) 'mul) ((eq i 'slash) 'div)) '()) l))
				)
			)
			(cons i s)
		)
	)
	(define (Factor i s)
		(if debug.parse (fmt "Factor" i))
		(cond
			((eq i 'left-par)
				(descend-into Expression (+ i 1) (cons (node.new 'begin-term '()) s)
					(lambda (a l)
						(if (eq a 'right-par)
							(cons (+ a 1) (cons (node.new 'end-term '()) l))
							(cons (- a) l)
						)
					)
					(lambda (a l)
						(cons a l)
					)
				)
			)
			((eq i 'number)
				(cons (+ i 1) (cons (node.new 'val (getp i)) s))
			)
			(else 
				(FunctionValue i s)
			)
		)
	)
	(define (Guard i s)
		(if (eq i 'bar)
			(descend-into LogicalExpression (+ i 1) (cons (node.new 'begin-cond '()) s)
				(lambda (a l)
					(if (eq a 'colon)
						(descend-into Expression (+ a 1) (cons (node.new 'cond-else '()) l)
							(lambda (b l)
								(cons b (cons (node.new 'end-cond '()) l))
							)
						)
						(cons a (cons (node.new 'end-cond '()) l))
					)
				)
			)
			(cons i s)
		)
	)
	(define (LogicalExpression i s)
		(if debug.parse (fmt "LogicExpr" i))
		(descend-into Expression i s
			(lambda (a l)
				(if (or (eq a 'tilde) (eq a 'bang) (eq a 'greater) (eq a 'less))
					(descend-into Expression (+ a 1) l
						(lambda (b l)
							(cons b 
								(cons 
									(node.new 
										(cond 
											((eq a 'tilde) 'eq) 
											((eq a 'bang) 'ne)
											((eq a 'greater) 'gt)
											((eq a 'less) 'lt)
										)
										'()
									)
									l
								)
							)
						)
					)
					(cons (- a) '())
				)
			)
		)
	)

	(define (FunctionValue i s)
		(if debug.parse (fmt "Func" i))
		(descend-into Identifier i s
			(lambda (a l)
				(ArgumentTuple a (cons (node.new 'const (getp i)) l))
			)
		)
	)
	(define (Expressions i s)
		(descend-into Expression i (cons (node.new 'begin-term '()) s)
			(lambda (a l)
				(if (eq a 'comma)
					(Expressions (+ a 1) (cons (node.new 'end-term '()) l))
					(cons a (cons (node.new 'end-term '()) l))
				)
			)
		)
	)
	(define (Identifier i s)
		(if debug.parse (fmt "Id" i (getp i)))
		(if (eq i 'word)
			(cons (+ i 1) s)
			(cons (- i) s)
		)
	)
	(define (Identifiers i s)
		(if debug.parse (fmt "Ids" i))
		(descend-into Identifier i (cons (node.new 'const (getp i)) s)
			(lambda (a l)
				(if (eq a 'comma)
					(Identifiers (+ a 1) l)
					(cons a l)
				)
			)
		)
	)
	(define (ParameterTuple i s)
		(if debug.parse (fmt "ParTuple" i))
		(if (eq i 'left-par)
			(descend-into Identifiers (+ i 1) (cons (node.new 'begin-pars '()) s)
				(lambda (a l)
					(if (eq a 'right-par)
						(cons (+ a 1) (cons (node.new 'end-pars '()) l))
						(cons (- a) l)
					)
				)
			)
			(cons i (cons (node.new 'end-pars '()) (cons (node.new 'begin-pars '()) s)))
		)
	)
	(define (ArgumentTuple i s)
		(if debug.parse (fmt "ArgTuple" i))
		(if (eq i 'left-par)
			(descend-into Expressions (+ i 1) (cons (node.new 'begin-args '()) s)
				(lambda (a l)
					(if (eq a 'right-par)
						(cons (+ a 1) (cons (node.new 'end-args '()) l))
						(cons (- a) l)
					)
				)
			)
			(cons i (cons (node.new 'end-args '()) (cons (node.new 'begin-args '()) s)))
		)
	)

	(Program 0)
)